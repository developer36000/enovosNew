const t=window.performance&&window.performance.now?()=>window.performance.now():()=>Date.now(),e="function"==typeof window.MutationObserver,i=window.requestAnimationFrame?window.requestAnimationFrame:e=>setTimeout(()=>e(t()),1e3/60);function s(t,e=0){let i;return function(...s){void 0!==i&&clearTimeout(i),i=setTimeout(()=>{i=void 0,t.apply(this,s)},e)}}function r(t){const e={};for(const i of Object.keys(t))e[i]={value:t[i]};return Object.defineProperties({},e)}function n(t=0,e=0,i=0,s=0){return{left:t,top:e,width:i,height:s,bottom:e+s,right:t+i}}function o(t){return t===document.documentElement?n(0,0,t.clientWidth,t.clientHeight):t.getBoundingClientRect()}function h(t){return t.width*t.height}class c{constructor(t,e,i,s,n,o){Object.defineProperties(this,{boundingClientRect:{value:e},intersectionRatio:{value:s},intersectionRect:{value:r(i)},rootBounds:{value:r(n)},target:{value:t},time:{value:o}})}}const u=n();function a(t,e){const i=Math.max(e.left,t.left),s=Math.min(e.right,t.right),r=Math.max(e.top,t.top);return n(i,r,s-i,Math.min(e.bottom,t.bottom)-r)}class d{constructor(t,e){this.target=t,this.observer=e,this.prevTargetRect=u,this.prevThreshold=0,this.prevRatio=0}updateIntersection(e,i){const s=o(this.target),r=this.getIntersectionData(e,i,s);let n=+r.exists;const h=r.ratio!==this.prevRatio,a=!((d=s).top===(l=this.prevTargetRect).top&&d.left===l.left&&d.right===l.right&&d.bottom===l.bottom);var d,l;let w;var f;if(r.exists&&(0!==(f=s).height||0!==f.width)&&(n=this.observer.getThresholdGreaterThan(r.ratio)),w=n!==this.prevThreshold,this.prevTargetRect=s,this.prevThreshold=n,this.prevRatio=r.ratio,r.exists||(r.ratio=0,r.rect=u),w){const e=new c(this.target,s,r.rect,r.ratio,i,t());this.observer.queueEntry(e)}return{ratioChanged:h,thresholdChanged:w,targetRectChanged:a}}getIntersectionData(t,e,i){const s=this.target;i||(i=o(this.target)),e||(e=o(t));const r=function(t,e){const i=document.documentElement;return t!==i&&!i.contains(t)||!t.contains(e)}(t,s),n=r?u:function(t,e,i,s){let r=s,n=e.parentNode,h=!1;for(;!h;){let e;n===t||1!==n.nodeType?(h=!0,e=i):"visible"!==window.getComputedStyle(n).overflow&&(e=o(n)),e&&(r=a(r,e)),n=n.parentNode}return r}(t,s,e,i),c=!r&&n.width>=0&&n.height>=0;return{rect:n,ratio:h(n)/h(i)||0,exists:c}}}const l="function"==typeof window.WeakMap&&"function"==typeof window.Map,w=(()=>{if(l)return window.WeakMap;function t(t,e){let i=-1;return t.some((t,s)=>{const r=t[0]===e;return r&&(i=s),r}),i}return class{constructor(){this.__entries__=[]}get(e){const i=t(this.__entries__,e);return this.__entries__[i][1]}set(e,i){const s=t(this.__entries__,e);~s?this.__entries__[s][1]=i:this.__entries__.push([e,i])}delete(e){const i=this.__entries__,s=t(i,e);~s&&i.splice(s,1)}has(e){return!!~t(this.__entries__,e)}}})(),f=l?window.Map:class extends w{get size(){return this.__entries__.length}clear(){this.__entries__.splice(0,this.__entries__.length)}entries(){return this.__entries__.slice()}keys(){return this.__entries__.map(t=>t[0])}values(){return this.__entries__.map(t=>t[1])}forEach(t,e){for(const i of this.__entries__)t.call(e,i[1],i[0])}};class p{constructor(t,e={threshold:0,rootMargin:"",root:void 0},i,s){if("function"!=typeof t)throw new TypeError("The callback provided as parameter 1 is not a function.");if("object"!=typeof e)throw new TypeError("parameter 2 is not an object.");if("root"in e&&!(e.root instanceof Element))throw new TypeError("member root is not of type Element.");const r=function(t=0){let e=t;return Array.isArray(t)?t.length||(e=[0]):e=[t],[e].map(t=>{if(t=Number(t),!window.isFinite(t))throw new TypeError("The provided double value is non-finite.");if(t<0||t>1)throw new RangeError("Threshold values must be between 0 and 1.");return t}).sort()}(e.threshold),n=function(t="0px"){const e=(t+"").split(/\s+/);if(e.length>4)throw new Error("Extra text found at the end of rootMargin.");return e[0]=e[0]||"0px",e[1]=e[1]||e[0],e[2]=e[2]||e[0],e[3]=e[3]||e[1],{rawData:e.join(" "),parsedData:e.map(t=>{let e,i;[,e,i]=/^(-?\d*\.?\d+)(px|%)$/.exec(t)||[];const s="px"===i;if(e=parseFloat(e),!window.isFinite(e))throw new Error("rootMargin must be specified in pixels or percent.");return s||(e/=100),{value:e,pixels:s}})}}(e.rootMargin);this.root=e.root||void 0,this.rootMargin=n.rawData,this.thresholds=Object.freeze(r),this._root=e.root||document.documentElement,this._callback=t,this._rootMargin=n.parsedData,this._targets=new f,this._quedEntries=[],this._publicObserver=s||this,this.controller=i}observe(t){if(!arguments.length)throw new TypeError("1 argument required, but only 0 present.");if(!(t instanceof Element))throw new TypeError('parameter 1 is not of type "Element".');const e=this._targets;e.has(t)||(e.set(t,new d(t,this)),this.controller.isConnected(this)||this.controller.connect(this),this.controller.startUpdateCycle())}unobserve(t){if(!arguments.length)throw new TypeError("1 argument required, but only 0 present.");if(!(t instanceof Element))throw new TypeError('parameter 1 is not of type "Element".');const e=this._targets;e.has(t)&&e.delete(t),e.size||this.disconnect()}disconnect(){this._targets.clear(),this.controller.disconnect(this)}takeRecords(){return this._quedEntries.splice(0)}notifySubscriber(){const t=this.takeRecords(),e=this._publicObserver;t.length&&this._callback.call(e,t,e)}queueEntry(t){this._quedEntries.push(t)}hasEntries(){return!!this._quedEntries.length}updateObservations(){const t=this._root,e=this.getRootRect();let i=!1;return this._targets.forEach(s=>{const r=s.updateIntersection(t,e);(r.ratioChanged||r.targetRectChanged)&&(i=!0)}),i}getThresholdGreaterThan(t){const e=this.thresholds,i=e.length;let s=0;for(;s<i&&e[s]<=t;)++s;return s}getRootRect(){return function(t,e){e=e.map((e,i)=>{let s=e.value;return e.pixels||(s*=i%2?t.width:t.height),s});const i={top:t.top-e[0],right:t.right+e[1],bottom:t.bottom+e[2],left:t.left-e[3],width:0,height:0};return i.width=i.right-i.left,i.height=i.bottom-i.top,i}(o(this._root),this._rootMargin)}}const v=new class{constructor(t=50,e=!1){this._idleTimeout=t,this._trackHovers=e,this._cycleStartTime=-1,this._isUpdateScheduled=!1,this._repeatCycle=!1,this._hoverInitiated=!1,this._mutationsObserver=void 0,this._isListening=!1,this._observers=[],this.startUpdateCycle=this.startUpdateCycle.bind(this),this.scheduleUpdate=this.scheduleUpdate.bind(this),this._onMutation=this._onMutation.bind(this),this._repeatHandler=s(this.scheduleUpdate,200),this._onMouseOver=s(this.startUpdateCycle,200)}get idleTimeout(){return this._idleTimeout}set idleTimeout(t){this._idleTimeout=t}connect(t){this.isConnected(t)||this._observers.push(t),this._isListening||this._initListeners()}disconnect(t){const e=this._observers,i=e.indexOf(t);~i&&e.splice(i,1),!e.length&&this._isListening&&this._removeListeners()}isConnected(t){return!!~this._observers.indexOf(t)}_updateObservers(){let t=!1;for(const e of this._observers)e.updateObservations()&&(t=!0),e.hasEntries()&&e.notifySubscriber();return t}startUpdateCycle(){this._cycleStartTime=t(),this.scheduleUpdate()}scheduleUpdate(t){if("number"==typeof t){const t=this._updateObservers();if(this._isUpdateScheduled=!1,!this._wasCycleStarted())return;t?this.startUpdateCycle():this._hasIdleTimeEnded()?this._onCycleEnded():this.scheduleUpdate()}else this._isUpdateScheduled||(i(this.scheduleUpdate),this._isUpdateScheduled=!0)}_hasIdleTimeEnded(){return t()-this._cycleStartTime>this._idleTimeout}_wasCycleStarted(){return-1!==this._cycleStartTime}_onCycleEnded(){this._cycleStartTime=-1,this._repeatCycle&&(this._cycleStartTime=0,this._repeatHandler())}_initListeners(){this._isListening||(this._isListening=!0,window.addEventListener("resize",this.startUpdateCycle,!0),window.addEventListener("scroll",this.scheduleUpdate,!0),this._trackHovers&&this._addHoverListener(),e?(this._mutationsObserver=new MutationObserver(this._onMutation),this._mutationsObserver.observe(document,{attributes:!0,childList:!0,characterData:!0,subtree:!0})):(this._repeatCycle=!0,window.addEventListener("click",this.startUpdateCycle,!0),this.startUpdateCycle()))}_removeListeners(){this._isListening&&(window.removeEventListener("resize",this.startUpdateCycle,!0),window.removeEventListener("scroll",this.scheduleUpdate,!0),this._removeHoverListener(),e?this._mutationsObserver&&(this._mutationsObserver.disconnect(),this._mutationsObserver=void 0):(this._repeatCycle=!1,window.removeEventListener("click",this.startUpdateCycle,!0)),this._isListening=!1)}enableHover(){this._trackHovers=!0,this._isListening&&this._addHoverListener()}disableHover(){this._trackHovers=!1,this._removeHoverListener()}isHoverEnabled(){return this._trackHovers}_addHoverListener(){this._hoverInitiated||(window.addEventListener("mouseover",this._onMouseOver,!0),this._hoverInitiated=!0)}_removeHoverListener(){this._hoverInitiated&&(window.removeEventListener("mouseover",this._onMouseOver,!0),this._hoverInitiated=!1)}_onMutation(t){t.every(t=>"attributes"!==t.type)?this.scheduleUpdate():this.startUpdateCycle()}},b=new w;class m{constructor(t,e){if(!arguments.length)throw new TypeError("1 argument required, but only 0 present.");const i=new p(t,e,v,this);Object.defineProperties(this,{root:{value:i.root},thresholds:{value:i.thresholds},rootMargin:{value:i.rootMargin}}),b.set(this,i)}static get idleTimeout(){return v.idleTimeout}static set idleTimeout(t){if("number"!=typeof t)throw new TypeError('type of "idleTimeout" value must be a number.');if("number"==typeof t&&t<0)throw new TypeError('"idleTimeout" value must be greater than 0.');v.idleTimeout=t}static get trackHovers(){return v.isHoverEnabled()}static set trackHovers(t){if("boolean"!=typeof t)throw new TypeError('type of "trackHovers" value must be a boolean.');t?v.enableHover():v.disableHover()}}["observe","unobserve","disconnect","takeRecords"].forEach(t=>{m.prototype[t]=function(){return b.get(this)[t](...arguments)}});class y{constructor(t,e,i){this.element=t,this.options=i,this.callback=e,this.initIntersectionObserver()}initIntersectionObserver(){this.element&&(this.observer=new m(t=>{t.forEach(t=>{const{isIntersecting:e,intersectionRatio:i}=t;this.callback(!0===e||i>0,t)})},this.options),this.observer.observe(this.element))}disconnectObserver(){this.observer&&(this.observer.disconnect(),this.observer=void 0)}}export{y as I}